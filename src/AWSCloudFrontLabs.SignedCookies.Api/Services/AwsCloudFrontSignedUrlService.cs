//#region Imports
//using Amazon.CloudFront;
//using AWSCloudFrontLabs.SignedCookies.Api.Configuration;
//using Microsoft.Extensions.Hosting;
//using Microsoft.Extensions.Options;
//using System;
//using System.IO;
//#endregion

//namespace AWSCloudFrontLabs.SignedCookies.Api.Services
//{
//    public class AwsCloudFrontSignedUrlService : IAwsCloudFrontService
//    {
//        #region Members

//        private readonly CloudFrontOptions _cloudFrontOptions;
//        private readonly IHostEnvironment _hostEnvironment;

//        #endregion

//        #region Ctor

//        public AwsCloudFrontSignedUrlService(IOptions<CloudFrontOptions> options, IHostEnvironment hostEnvironment)
//        {
//            _cloudFrontOptions = options.Value;
//            _hostEnvironment = hostEnvironment;
//        }

//        #endregion


//        #region Methods

//        public static string CreateCannedPrivateURL(string urlString, string durationUnits,
//            string durationNumber, string pathToPolicyStmnt, string pathToPrivateKey, string privateKeyId)
//        {
//            // args[] 0-thisMethod, 1-resourceUrl, 2-seconds-minutes-hours-days to expiration, 3-numberOfPreviousUnits, 
//            // 4-pathToPolicyStmnt, 5-pathToPrivateKey, 6-PrivateKeyId

//            TimeSpan timeSpanInterval = GetDuration(durationUnits, durationNumber);

//            // Create the policy statement.
//            string strPolicy = CreatePolicyStatement(pathToPolicyStmnt,
//                urlString, DateTime.Now, DateTime.Now.Add(timeSpanInterval), "0.0.0.0/0");
//            if ("Error!" == strPolicy) return "Invalid time frame.  Start time cannot be greater than end time.";

//            // Copy the expiration time defined by policy statement.
//            string strExpiration = CopyExpirationTimeFromPolicy(strPolicy);

//            // Read the policy into a byte buffer.
//            byte[] bufferPolicy = Encoding.ASCII.GetBytes(strPolicy);

//            // Initialize the SHA1CryptoServiceProvider object and hash the policy data.
//            using (SHA1CryptoServiceProvider cryptoSHA1 = new SHA1CryptoServiceProvider())
//            {
//                bufferPolicy = cryptoSHA1.ComputeHash(bufferPolicy);

//                // Initialize the RSACryptoServiceProvider object.
//                RSACryptoServiceProvider providerRSA = new RSACryptoServiceProvider();
//                XmlDocument xmlPrivateKey = new XmlDocument();

//                // Load the PrivateKey.xml file generated by ConvertPEMtoXML.
//                xmlPrivateKey.Load(pathToPrivateKey);

//                // Format the RSACryptoServiceProvider providerRSA and create the signature.
//                providerRSA.FromXmlString(xmlPrivateKey.InnerXml);
//                RSAPKCS1SignatureFormatter rsaFormatter = new RSAPKCS1SignatureFormatter(providerRSA);
//                rsaFormatter.SetHashAlgorithm("SHA1");
//                byte[] signedPolicyHash = rsaFormatter.CreateSignature(bufferPolicy);

//                // Convert the signed policy to URL safe base 64 encoding.
//                string strSignedPolicy = ToUrlSafeBase64String(signedPolicyHash);

//                // Concatenate the URL, the timestamp, the signature, and the key pair ID to form the private URL.
//                return urlString + "?Expires=" + strExpiration + "&Signature=" + strSignedPolicy + "&Key-Pair-Id=" + privateKeyId;
//            }
//        }

//        public static string CreateCustomPrivateURL(string urlString, string durationUnits,
//            string durationNumber, string startIntervalFromNow, string ipaddress, string pathToPolicyStmnt,
//            string pathToPrivateKey, string PrivateKeyId)
//        {
//            // args[] 0-thisMethod, 1-resourceUrl, 2-seconds-minutes-hours-days to expiration, 
//            // 3-numberOfPreviousUnits, 4-starttimeFromNow, 5-ip_address, 6-pathToPolicyStmt, 7-pathToPrivateKey, 8-privateKeyId

//            TimeSpan timeSpanInterval = GetDuration(durationUnits, durationNumber);
//            TimeSpan timeSpanToStart = GetDurationByUnits(durationUnits, startIntervalFromNow);
//            if (null == timeSpanToStart)
//                return "Invalid duration units. Valid options: seconds, minutes, hours, or days";

//            string strPolicy = CreatePolicyStatement(
//                pathToPolicyStmnt, urlString, DateTime.Now.Add(timeSpanToStart), DateTime.Now.Add(timeSpanInterval), ipaddress);

//            // Read the policy into a byte buffer.
//            byte[] bufferPolicy = Encoding.ASCII.GetBytes(strPolicy);

//            // Base64 encode URL-safe policy statement.
//            string urlSafePolicy = ToUrlSafeBase64String(bufferPolicy);

//            // Initialize the SHA1CryptoServiceProvider object and hash the policy data.
//            byte[] bufferPolicyHash;
//            using (SHA1CryptoServiceProvider cryptoSHA1 = new SHA1CryptoServiceProvider())
//            {
//                bufferPolicyHash = cryptoSHA1.ComputeHash(bufferPolicy);

//                // Initialize the RSACryptoServiceProvider object.
//                RSACryptoServiceProvider providerRSA = new RSACryptoServiceProvider();
//                XmlDocument xmlPrivateKey = new XmlDocument();

//                // Load the PrivateKey.xml file generated by ConvertPEMtoXML.
//                xmlPrivateKey.Load("PrivateKey.xml");

//                // Format the RSACryptoServiceProvider providerRSA and create the signature.
//                providerRSA.FromXmlString(xmlPrivateKey.InnerXml);
//                RSAPKCS1SignatureFormatter RSAFormatter = new RSAPKCS1SignatureFormatter(providerRSA);
//                RSAFormatter.SetHashAlgorithm("SHA1");
//                byte[] signedHash = RSAFormatter.CreateSignature(bufferPolicyHash);

//                // Convert the signed policy to URL safe base 64 encoding.
//                string strSignedPolicy = ToUrlSafeBase64String(signedHash);

//                return urlString + "?Policy=" + urlSafePolicy + "&Signature=" + strSignedPolicy + "&Key-Pair-Id=" + PrivateKeyId;
//            }
//        }

//        #endregion



//        public static TimeSpan GetDuration(string units, string numUnits)
//        {
//            TimeSpan timeSpanInterval = new TimeSpan();
//            switch (units)
//            {
//                case "seconds":
//                    timeSpanInterval = new TimeSpan(0, 0, 0, int.Parse(numUnits));
//                    break;
//                case "minutes":
//                    timeSpanInterval = new TimeSpan(0, 0, int.Parse(numUnits), 0);
//                    break;
//                case "hours":
//                    timeSpanInterval = new TimeSpan(0, int.Parse(numUnits), 0, 0);
//                    break;
//                case "days":
//                    timeSpanInterval = new TimeSpan(int.Parse(numUnits), 0, 0, 0);
//                    break;
//                default:
//                    Console.WriteLine("Invalid time units; use seconds, minutes, hours, or days");
//                    break;
//            }
//            return timeSpanInterval;
//        }

//        private static TimeSpan GetDurationByUnits(string durationUnits, string startIntervalFromNow)
//        {
//            TimeSpan timeSpanInterval = new TimeSpan();
//            switch (durationUnits)
//            {
//                case "seconds":
//                    timeSpanInterval = new TimeSpan(0, 0, int.Parse(startIntervalFromNow));
//                    break;
//                case "minutes":
//                    timeSpanInterval = new TimeSpan(0, int.Parse(startIntervalFromNow), 0);
//                    break;
//                case "hours":
//                    timeSpanInterval = new TimeSpan(int.Parse(startIntervalFromNow), 0, 0);
//                    break;
//                case "days":
//                    timeSpanInterval = new TimeSpan(int.Parse(startIntervalFromNow), 0, 0, 0);
//                    break;
//                default:
//                    timeSpanInterval = new TimeSpan(0, 0, 0, 0);
//                    break;
//            }
//            return timeSpanInterval;
//        }

//        public static string CopyExpirationTimeFromPolicy(string policyStatement)
//        {
//            int startExpiration = policyStatement.IndexOf("EpochTime");
//            string strExpirationRough = policyStatement.Substring(startExpiration + "EpochTime".Length);
//            char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' };
//            List<char> listDigits = new List<char>(digits);
//            StringBuilder buildExpiration = new StringBuilder(20);
//            foreach (char c in strExpirationRough)
//            {
//                if (listDigits.Contains(c))
//                    buildExpiration.Append(c);
//            }
//            return buildExpiration.ToString();
//        }

//    }
//}
